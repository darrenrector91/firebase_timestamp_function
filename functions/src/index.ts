// firebase deploy --only functions

// import the 'firebase-functions' module and makes it avalaible via this 'functions' identifier:
import * as functions from "firebase-functions";

// import the 'firebase-admin' module and makes it avalaible via this 'admin' identifier:
// CAUTION!!! This gives this code full read/write rights from/to the Realtime Database.
import * as admin from "firebase-admin";

// initialize an admin app instance from which Realtime Database changes can be made:
admin.initializeApp();

// The Cloud Function named formatData below responds to any node creation
// in the database path '/measures/{pushId}/', for instance 1023 in case
// of maximum luminosity. {pushId} (with curly braces) is a wildcard,
// representing for us the autogenerated pushId associated with the newly
// pushed measure, for instance '-LGuXlb0GZfwbKs0Rf8Y'.
export const formatSoilData = functions.database
  .ref("/soil_moisture/{pushId}/")
  .onCreate(
    // The onCreate() trigger function requires a handler function that itself
    // receives 2 arguments: We name them snapshot and context.
    // (The handler function is written here as an anonymous function with
    // fat arrow syntax.)
    (snapshot, context) => {
      // Grab the current value of what was written to the Realtime Database
      // by applying val() method to the snapshot raw object:
      const original = snapshot.val(); // 1023
      // Grab the wildcard we called pushId in the database path. It lies
      // in the context object:
      const pushId = context.params.pushId; // '-LGuXlb0GZfwbKs0Rf8Y'
      // Let's print them in Firebase Console (use of template literals syntax):
      console.log(`Detected new measure ${original} with pushId ${pushId}`);
      // Let's push to 'timestamped_measures' node a new object
      // with an autogenerated push ID for key and a 2-property object for value:
      return admin
        .database()
        .ref("soil_moisture_ts")
        .push({
          value: original,
          timestamp: admin.database.ServerValue.TIMESTAMP // will be Epoch time in ms
        });
    }
  );
// Why 'return' at the end of the handler function, in front
// of the push method?
// In fact, the handler function must return a Promise, an object that ends
// up 'resolved' or 'rejected', thus indicating to the Cloud Function
// it can close as the work is done.
// push() does asynchronous work. Unsurprisingly, push() returns a Promise.
// This is the one the handler function shall return.

export const formatTempData = functions.database
  .ref("/temperature/{pushId}/")
  .onCreate((snapshot, context) => {
    const original = snapshot.val(); // 1023
    const pushId = context.params.pushId; // '-LGuXlb0GZfwbKs0Rf8Y'
    console.log(`Detected new measure ${original} with pushId ${pushId}`);
    return admin
      .database()
      .ref("temperature_ts")
      .push({
        value: original,
        timestamp: admin.database.ServerValue.TIMESTAMP
      });
  });

export const formatLightata = functions.database
  .ref("/light/{pushId}/")
  .onCreate((snapshot, context) => {
    const original = snapshot.val(); // 1023
    const pushId = context.params.pushId; // '-LGuXlb0GZfwbKs0Rf8Y'
    console.log(`Detected new measure ${original} with pushId ${pushId}`);
    return admin
      .database()
      .ref("light_ts")
      .push({
        value: original,
        timestamp: admin.database.ServerValue.TIMESTAMP
      });
  });
